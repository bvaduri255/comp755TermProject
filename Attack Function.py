# -*- coding: utf-8 -*-
"""Testing Class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GiI2KnSdUevrq1CueWEytsm-Oimwb4b1
"""

# pip install adversarial-robustness-toolbox

import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers.legacy import Adam
from tensorflow.keras.losses import categorical_crossentropy
from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D
from tensorflow.keras import metrics
from art.attacks.inference.membership_inference import MembershipInferenceBlackBox
from art.estimators.classification import KerasClassifier
from art.utils import load_mnist
from tqdm import tqdm

tf.compat.v1.disable_eager_execution()

(x_train, y_train), (x_test, y_test), min_pixel_value, max_pixel_value = load_mnist()

def create_model():
    model = Sequential()
    model.add(Conv2D(filters=4, kernel_size=(5, 5), strides=1, activation="relu", input_shape=(28, 28, 1)))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Conv2D(filters=10, kernel_size=(5, 5), strides=1, activation="relu"))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Flatten())
    model.add(Dense(100, activation='relu'))
    model.add(Dense(10, activation='softmax'))
    model.compile(optimizer=Adam(), loss=categorical_crossentropy, metrics=[metrics.categorical_accuracy])
    model.layers[0].set_weights((np.load('TEMP_model_weights/zero_layer_weights.npy'), np.load('TEMP_model_weights/zero_layer_biases.npy')))
    model.layers[2].set_weights((np.load('TEMP_model_weights/two_layer_weights.npy'), np.load('TEMP_model_weights/two_layer_biases.npy')))
    model.layers[5].set_weights((np.load('TEMP_model_weights/five_layer_weights.npy'), np.load('TEMP_model_weights/five_layer_biases.npy')))
    model.layers[6].set_weights((np.load('TEMP_model_weights/six_layer_weights.npy'), np.load('TEMP_model_weights/six_layer_biases.npy')))
    return model

x_training = x_train[:7000, :]
y_training = y_train[:7000, :]

x_evals = x_test[:int(0.7*len(x_test)), :]
y_evals = y_test[:int(0.7*len(y_test)), :]

# art_train_attack_x = x_train[:len(x_train) - int(len(0.7*x_train)), :]
# art_eval_attack_x = x_test[:len(x_test) - int(len(0.7*x_test)), :]
art_train_attack_x = x_train[:100]
art_eval_attack_x = x_test[:100]
art_attack_x = np.vstack([art_train_attack_x, art_eval_attack_x])

# art_train_attack_y = y_train[:len(y_train) - int(len(0.7*y_train))]
# art_eval_attack_y = y_test[:len(y_test) - int(len(0.7*y_test))]
art_train_attack_y = y_train[:100]
art_eval_attack_y = y_test[:100]
art_attack_y = np.vstack([art_train_attack_y, art_eval_attack_y])


global_model = create_model()


model = KerasClassifier(model=global_model)
mi = MembershipInferenceBlackBox(model, attack_model_type="nn", input_type="prediction", nn_model_batch_size=128)
mi.fit(x_training, y_training, x_evals, y_evals)
values = mi.infer(art_attack_x, art_attack_y, probabilities=True)
print(values)

values = mi.infer(art_attack_x, art_attack_y, probabilities=False)
reals = np.vstack([np.ones((100,1)), np.zeros((100,1))])
print(np.sum(np.abs(values-reals)))